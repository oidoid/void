parser
  get demo working with parser that generates zoo graph. trying to make zoo init a one liner and strip down what's needed in the Void subclass. I will translate future level editor outputs to the schema. it's easy to keep lists distinct in the zoo using queries.
  parser assembles initial queries using registered systems.
  extract Sprite.pool to dyrnamicRef.
  minimize code size.
    assume valid config. linter handles invalid.
    how far can I get by using zero defaults for everything? not much breaks. just scale?
    use nonstandard wild card JSON import and make a stripped down .min.json too.
      https://esbuild.github.io/try/#YgAwLjI1LjEyAC0tYnVuZGxlIC0tZm9ybWF0PWVzbSBlbnRyeS5qcyAtLXRhcmdldD1lczIwMjQAZQBlbnRyeS5qcwBpbXBvcnQgKiBhcyBmb28gZnJvbSAnLi9mb28uanNvbicgLy93aXRoIHt0eXBlOiAnanNvbid9CmltcG9ydCAqIGFzIGJhciBmcm9tICcuL2Jhci5qc29uJyAvL3dpdGgge3R5cGU6ICdqc29uJ30KCmNvbnNvbGUubG9nKGZvby5mb28uYmF6LmJvbykKY29uc29sZS5sb2coYmFyLmZvby5iYXopAABmb28uanNvbgB7CiAgImZvbyI6IHsiYmF6IjogeyJib28iOiAiZG9uZSJ9fSwgImJhciI6ICJiYXIiCn0AAGJhci5qc29uAHsKICAiZm9vIjogeyJiYXoiOiAiZG9uZTIifSwgImJhciI6ICJiYXIiCn0
ecs
  review my research tabs and convos.
  pop out old void ECS. git show f812f85 -- src/ecs.
    ```
    import { FPS, QueryEnt, System, Text } from '@/void'

    export type FPSEnt = QueryEnt<{ fps: FPS; text: Text }, typeof query>

    const query = 'fps & text'

    export class FPSSystem implements System<FPSEnt> {
      readonly query = query

      runEnt(ent: FPSEnt): void {
        const now = performance.now()
        if ((now - ent.fps.next.created) >= 1000) {
          ent.fps.prev = ent.fps.next.frames
          ent.fps.next = { created: now, frames: 0 }
        }
        ent.fps.next.frames++
        ent.text.str = ent.fps.prev.toString().padStart(3, '0')
      }
    }
    ```
  compare current Super Patience (very tiny!) and previous Super Patience, bees demo.
  zoo manages queries.
  printZoo() in demo or debug flag if more universally useful.
  all dimensional ents use Sprite which XYWH and z (defaulting to hidden) and do not require an extra copy. sprite groups will have a root `Sprite` that is likely hidden.
  private data is just a more specific component like `followCam {stateInitByParserNotJSON}'. most components are objects (`{}`).
  instantiated ents retain ID, name, and are given an EID. debug lines print each.
  ? components are saved to like arrays. queries are indices into arrays.
    this makes a ton of sense for xy. Float16Array[index * 2] even works. less sense for a nine patch. could be both SoA or AoS.
  review 1M+ particle test for iteration perf.

port super patience.
  map space bar, cursor keys, wasd, that's it.




demo
  add lose context trigger button.
  add download screenshot button.
  add fullscreen button to demo.
  add sound synth on button press.
  add `Sprite.looped` animation. hourglass or widget?
  add sticky notes.
    tweet notes. either it fits in 140 or it doesn't. you have to be thoughtful. you can publish to a readonly queue though. maybe that just happens automatically to the last entry when a new entry is made. you lose editing. you can reorder though.
    make a friendly note taking app that is Mario Paint fun.
bugs
  reinvestigate fullscreen movement delta scaling. I can't get this to work.
  I'm getting Node.js type suggestions in src and demo. types is empty. only happens when jsdom or html minifier are installed. `npx tsc -p src/ --listFiles` lists no @types files. everything is pure TS lib or project files. doesn't matter when I blank typeRoots and remove types: 'node' from other projects.
perf
  review gamepad connection event support.
  experiment with caching `Sprite` hitbox and hurtbox.
    add cached hit/hurtbox tests to sprite.
  provide quadtree.
    https://lisyarus.github.io/blog/posts/building-a-quadtree.html
  minify GLSL
    https://github.com/vanruesc/esbuild-plugin-glsl/blob/main/src/minifyShader.ts
    https://github.com/UstymUkhman/vite-plugin-glsl/blob/main/src/loadShader.js
  mem pool should move hidden sprites to end and not send. could also just have sprite interface or list of sprites I don't send to GPU.
input
  restore left hand keys for DefaultButton.
  how can I make two button combos friendlier? this is impossible to time at the same time and it's unclear how to resolve within a window. all buttons pressed sounds good. even if I remove gap requirement, you end up pressing A, A+B, B instead of A+B. generate multiple interpretations each press and union result. for "A, A+B", you can't slide from A to B without a release and releasing buttons after "A, A+B, A+B+C" doesn't cause "A, A+B, A+B+C, B+C, C". my ideal is: new sequence after an off release, otherwise aggregate for like 60ms. see test "combos require gaps between presses".
    A-off-A+B-off-A-off-A -> A-A+B-A-A
    A-off-A-B-off-A-off-A -> A-A+B-A-A, don't care if also A-A-B-A-A
    U-U+R-R-R+D-D-D+L-L-L+U -> U-U+R-R-R+D-D-D+L-L-L+U
  `isCombo('A+B', 'A', 'A', 'A', 'U+L+A')` syntax? +update get combo.
output
  add disk saving to storage. https://github.com/GoogleChromeLabs/browser-fs-access.
rendering
  add sprite rotation. switch between AABB collisions?
parser
  populate tags in demo/schema/level-file.json from tools/void.ts once `$dynamicRef` is understood by IDEs. see https://github.com/microsoft/vscode/issues/155379.
  wrap AJV into linter and switch to dynamic refs.
